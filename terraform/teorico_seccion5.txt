VPC - Virtual Private Network
-----------------------------
- aisla las instancias a nivel de red
- Buena practica: siempre lanzar instancias en una VPC:
    - default
    - o una creada y manejada por terraform
- para setups medianos o chicos un VPC x region esta Ok
- Una instancia de un VPC no se puede comunicar con otra VPC usando
IP privada (si con ip publica, pero no recomendado)
- Se pueden linkear 2 VPCs (peering)

Private SubNets
----------------
10.0.0.0/8  10.0.0.0-10.255.255.255 mask: 255.0.0.0
172.16.0.0/12   172.16.0.0-172.31.255.255 mask:(default de aws)
192.168.0.0/16  192.168.0.0-192.168.255.255

- Cada Zona (ej: us-west-1) tiene su propia Subnet publica y privada

- Cada Subnet Publica esta conectada a un Internet Gateway. Estas instancias
tambien tienen una IP publica para ser alcanzadas desde internet

- services y applications van en la public subnet
- backend, db, caching server van en la private subnet
- Load Balancer tipicamente en la public subnet y las instancias sirviendo
una aplicacion en la private subnet


Ejemplo vpc.tf:
--------------
cidr_block: Classess Inter-Domain Routing. El tamaÃ±o completo de la red. Dentro van
            las subnets
instance_tenancy: Multiple instances en un mismo hardware. Se puede cambiar si
                  se necesita una unica instancia por maquina fisica (sale mas $)

enable_classiclink = false (por si se quiere linkear a EC2 classic. Otro tipo de red de aws)

map_public_ip_on_launch: pedir o no una IP publica (para subnet public). Cuando
                         lance una instancia en una subnet public va a obtener una ip
                         en el rango cidr_block (privado) de esa subnet y una ip publica


# Internet GW
resource "aws_internet_gateway" "main-gw" {
  vpc_id = aws_vpc.main.id
  tags = {
    Name = "main"
  }
}

Route tables son aplicadas a las Instancias (solo si las asocio con las regals de asociacion)
# Route tables
resource "aws_route_table" "main-public" {
  vpc_id = aws_vpc.main.id
  route {
    cidr_block = "0.0.0.0/0"                # Todo el trafico que no sea interno de la VPC va por default gw
    gateway_id = aws_internet_gateway.main-gw.id    # Este es el default gw
  }
  tags = {
    Name = "main-public-1"
  }
}
# route associations public -- esta es la asignacion del default gw de c/subnet
resource "aws_route_table_association" "main-public-1-a" {
  subnet_id = aws_subnet.main-public-1.id
  route_table_id = aws_route_table.main-public.id
}

# NAT GW -- para proveer acceso a internet a las instancias de la  red privada, pero no vicecersa
-------------------------------------------------------------------------------------------------

resoruce "aws_eip" "nat" { --> es una ip estatica (elasticIP)
    vpc = true
}


Correr EC2 en VPC
-----------------

- con security groups (simil iptables)

--------------
# EBS Volumes - Block Storage
----------------------------
- t2.micro por defecto tiene 8G de EBS. Automaticamente eliminado cuando la instancia se termina
- Algunas instancias tienen lo que se llama Ephemeral Storage (storage local) que se elimina cuando la
instancia se elimina.

Agregar Extra Volumne (persistente post destruccion de la instancia)

# La instancia
resource "aws_instance" "example" {
}

# el Storage
resource "aws_ebs_volume" "ebs-volume-1" {
  availability_zone = "us-west-1"
  size = 20     # Gib
  type = "gp2"  # general prupose storage. Opciones [standard, io1, st1]
  tags = {
    Name = "extra volume data"
  }
}

# La asignacion del device
resource "aws_volume_attachment" "ebs-volume-1-attachment" {
  device_name = "/dev/xvdh"
  instance_id = aws_instance.example.id
  volume_id = aws_ebs_volume.ebs-volume-1.id
}

Si quiero agrandar (los 8G) el storage del root volume en la definicion de instancia:

root_block_device {
    volume_size = 16
    volume_type = "gp2"
    delete_on_termination = "true" # cuando se elimina la instancia
}


# Userdata:
-------------
- Customization at launch. Se ejecuta en la creacion de la instancia, no en el reboot
- install extra soft
- prepare instance to join a cluster
- exec command/scripts
- mount volumes
-
Ejemplo userdata en una linea de string
----------------------------------------
resource "aws_instance" "example" {
....
    # userdata
    user_data = "#!/bin/bash\nwget http://instalador_openvpn/paquete.deb\ndpkg -i paquete.deb"
}

Ejemplo userdata (mejor) con Templates
--------------------------------------

resource "aws_instance" "example" {
....
    user_data = data.template_cloudinit_config.cloudinit-example.rendered
}


# Static IPs, EIPs, Route53
----------------------------

- ips privadas son auto asignadas a EC2
- cada subnet de VPC tiene su propio rango (ej: 10.0.1.0-255
- Puedo harcodear una IP fija

resource "aws_instance" "ej" {
    ....
    subnet_id = aws_subnet.main-public-1.id
    private_ip = 10.0.1.4   # tiene que estar en el range de la subnet
}

# EIP (Elastic IP addresses) - Publicas
---------------------------------------

resource "aws_instance" "ej" {
    ....
    subnet_id = aws_subnet.main-public-1.id
    # Le asigno una ip privada
    private_ip = 10.0.1.4   # tiene que estar en el range de la subnet
}
# Con este resource agrego la IP PUBLICA estatica
resource "aws_eip" "ex-eip" {
    instance = aws_instance.example.id
    vpc = true
}
aws_eip.ex-ip.public_ip attribute en out

* Si se reserva un EIP y no se usa en una instancia, hay que pagarla, de otra manera es gratis


# Route 53
----------
resource "aws_route53_zone" "example-com" {
    name = "example.com"
}
resource "aws_route53_record" "server1-record" {
    zone_id = aws_route53_zone.example-com.zone_id
    name = "server1.example.com"
    type = "A"
    ttl = "300"
    records = [aws_eip.example-eip.public_ip]
}

Como saber los nameserver de tu dominio para tu NIC.
property: aws_route53_zone.example-com.name_servers


# RDS - Relational Database Services
------------------------------------

- replication. High availability (una master y otra standby, si se cae pasa a master)
- automated snapshots (for backups)
- automated security updates
- easy instance replacement (vertical scaling)
Se le puede indicar modificar cpu, ram, etc y hay un downtime de minutos.

BD: Mysql, MariaDB, PostgreSQL, Microsoft SQL, Oracle.

Pasos:
-----
1. Crear un subnet group que permita especificar en que subnets va a estar la BD (ejemplo eu-west-1a y eu-west-1b)

# Este grupo especifica que el RDS sera puesto en estas private subnets(1 o 2)
EN HA, habra una instancia en cada una

resource "aws_db_subnet_group" "mariadb-subnet" {
    name = "mariadb-subnet"
    description = "RDS subnet group"
    # las subnets donde el RDS deberia correr
    subnet_ids = [aws_subnet.main-private-1.id, aws_subnet.main-private-2.id]
}

2. Crear un Parameter Group:
    Permite especificar parametros para cambiar los settings en la BD

resource "aws_db_parameter_group" "mariadb-parameters" {
  name = "mariadb-parameters"
  family = "mariadb10.1"
  description = "MariaDB parameter group"

  parameter {   # Estos params se pasan al config file
    name = "max_allowed_packet"
    value = "16777216"
  }
}

3. Crear un Security Group para permitir el trafico a la RDS

resource "aws_security_group" "allow-mariadb" {
  vpc_id = aws_vpc.main.id
  name = "allow-mariadb"
  description = "allow-mariadb"

  ingress {
    from_port = 3306
    to_port = 3306
    protocol = "tcp"
    # permito aaceso de nuestra instancia "example"
    security_groups = [aws_security_group.example.id]   # En vez de poner un cidr pongo otro security group
  }
  egress {
    from_port = 0
    to_port = 0
    protocol = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    self = true
  }
  tags = {
    Name = "allow-mariadb"
  }
}


4. Crear la RDS

resource "aws_db_instance" "mariadb" {
  allocated_storage = 100 # 100 GB gives us more IOPS
  engine = "mariadb"
  engine_version = "10.1.14"
  instance_class = "db.t2.micro"
  identifier = "mariadb"
  name = "mariadb"
  username = "root" # el que quiera
  password = "qwerty"
  db_subnet_group_name = aws_db_subnet_group.mariadb-subnet.name
  parameter_group_name = "mariadb-parameters"
  multi_az = false # set tru to have HA. 2 instances synchronized with each other
  vpc_security_group_ids = [aws_security_group.allow-mariadb.id]
  storage_type = "gp2"
  backup_retention_period = 30 # dias de backup
  availability_zone = aws_subnet.main-private-1.availability_zone   # Prefered AZ
  tags = {
    Name = "mariadb-instance"
  }
}





















